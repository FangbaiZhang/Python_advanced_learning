# -*- coding:utf-8 -*-

import re

# Python中字符串前面加上 r 表示原生字符串，去掉python中的各种特殊含义
# Python和re中的\都有特殊含义
# 与大多数编程语言相同，正则表达式里使用"\"作为特殊含义字符，这就可能造成反斜杠困扰。
# 假如你需要匹配文本中的字符"\"，那么使用编程语言表示的正则表达式里将需要4个反斜杠"\\\\"：
# 前两个和后两个分别用于在编程语言里转义成反斜杠，
# 转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。
# Python里的原生字符串很好地解决了这个问题，有了原生字符串，
# 你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。


# python中\使用一个都是有转义含义
# \a \b在python中都有特殊含义，所以打印不出来
mm = "c:\a\b\c"
print(mm)

# 使用两个\\去掉转义含义或者使用r
mm = "c:\\a\\b\\c"
print(mm)

# 字符串前面使用，r去掉\的转义含义，代表后面就是一个纯字符串
mm = r"c:\a\b\c"
print(mm)
print('*' * 50)

# 不使用r，正则匹配\需要使用四个\\\\
# re里面的\是有特殊含义的，re匹配\需要使用\\,第一个\去掉特殊含义
# 上面的re要匹配一个\需要使用\\
# 但是：在python里面\也是转义符,\\代表一个\
# re的第一个\python需要\\表示，第二个\还是需要\\表示
# 因此，直接写表达式，python中传到re中，需要\\\\表示匹配一个\

mm = "c:\\a\\b\\c"
ret = re.match('c:\\\\a', mm)
print(ret.group())

mm = r"c:\a\b\c"
ret = re.match('c:\\\\a', mm)
print(ret.group())
print('*' * 50)

# 正则表达式使用r,使用两个反斜杠即可
# 加上r，就是为了告诉python解释器，
# 表达式c:\\a就是原生字符串，\没有转义含义，
# 传个re的就是\\，re中\\匹配的就是一个\
# 第一个反斜杠表示re中去掉反斜杠的特殊含义
mm = "c:\\a\\b\\c"
ret = re.match(r'c:\\a', mm)
print(ret.group())
print('*' * 50)



