- 参考：Python_advanced_learning中的02高级语法补充002_多进程_多线程_协程
- 参考：TLXY_study_note中的高级语法部分(已重新整理到上面的002文件夹中)
- 参考：Spider_development_study_note中的READ.MD和ch01中的代码示例(已重新整理到上面的002文件夹中)

1. 进程与线程的区别

- 进程：程序运行的一个状态
    - 包含地址空间，内存，数据栈等资源
    - 每个进程有自己独立的运行环境
    - 多进程共享数据是一个问题
    - 任务管理器中可以运行运行多个网络调试助手或QQ等程序，就是多个进程

- 线程
    - 一个进程的独立运行片段，一个进程可以有多个线程
    - 轻量化的进程
    - 一个进程的多个线程共享数据和上下文运行环境
    - 多线程共享全局变量
    - 共享互斥问题

- 协程
    - 协程就是一个可以暂停执行的函数，或者可以理解成一个yield生成器
    - 协程是python个中另外一种实现多任务的方式，
    - 只不过比线程更小占用更小执行单元（理解为需要的资源）。
    - 协程调用一个任务就类似于调用一个函数一样，消耗的资源最小
    - 协程是一个执行单元，自带CPU上下文。
    - 协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住
    
2. 进程之间的通信
    - 两个进程使用Pipe
    - 多个进程使用Queue
    - Queue实际就是一个安全队列
    - Queue提供了一个基本的FIFO容器,
    - Queue有两个方法Put和Get
    - put()方法向容器中存入数据，按顺序存入
    - get()方法从容器中取出数据，按循序取出

- 多进程使用multiprocessing模块
- 多线程使用threading模块

3. 全局解释器(GIL)
    - Python代码的执行是由python虚拟机进行控制
    - Python语言本身并没有GIL问题，是python虚拟机(Python解释器)的问题
    - 在主循环中只能有一个线程在执行，每个线程执行的时候都需要先获取GIL，
    - 以保证同一时刻只有一个线程在执行代码
    
    - 多进程：多个代码在独立同时进行，真正的多并发，占用内存多个进程之和
    - 多线程：多个代码同时执行，由于存在GIL，同时只有一个线程再执行，
        这个不执行，下一个才执行，内部先获取锁，释放锁
    - 因此，多线程是伪多并发，占用内存还是一个进程的
    - Python使用多进程才能利用CPU的多核资源
    
    - 线程释放GIL锁的情况：在IO操作等可能会引起阻塞的system call之前，可以暂时释放GIL，
    - 但在执行完毕后，必须重新获取GIL
    
    - 解决多线程的GIL问题：
    - 方法1：更换python解释器（默认解释器是C语言编写的），换成java写的解释器jypython
    - 方法2：用其它语言替代多线程代码，python胶水语言，可以直接调用c语言，java语言等写的代码
    
4. 多线程和多进程的使用   
    - 计算密集型：代码没有等待时间，使用多进程，发挥多核的性能
    - IO密集型（input,output)，比如网络收发，文件读写，具有等待时间
    - 比如：请求网络，发出请求，假设需要等待时间1分钟，然后返回内容，
    - 这个等待时间就可以先解锁当前线程，因为还在等待返回内容，开始下个线程
    - 等待的1分钟内可以发出多个请求，返回内容回来时候，再次请求锁，不断上锁解锁
    - 网页爬取：多线程比单线程爬取性能有提升，因为遇到IOS阻塞会自动释放GIL锁