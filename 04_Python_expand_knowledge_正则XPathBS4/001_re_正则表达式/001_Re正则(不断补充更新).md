# **Python高级语法——正则表达式和XPath——学习心得笔记**
  
# 1. 正则表达式（Regular Expression）
- 正则表达式(Regular Expression)是一种文本模式
- 包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为"元字符"）
- 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串
- 常常用来检索，替换某些模式的文本

- 正则表达式写法
    ^	匹配字符串的开头
    $	匹配字符串的末尾。
    .	匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。
    [...]	用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
    [^...]	不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
    *	匹配0个或多个的表达式,贪婪模式(*号前面的一个字符)。
    +	匹配1个或多个的表达式(+号前面的一个字符)。
    ?	匹配0个或1个由问好前面字符或者表达式，非贪婪方式(?号前面的一个字符)
    |   匹配左右任意一个表达式，类似于or或
    \   \{.*\} 反斜杠和特殊符号使用，就是去掉该符号的特殊含义，\即去转义符
        \{即匹配字符串中的{符号，\\即匹配一个反斜杠
    \   一般是\1 \2 \3...，由于匹配与前面的第一个分组，第二个分组...一模一样的字符，类似位置参数
    (?P<name>分组的内容) 	?P<name>用于给分组起别名，类似于关键参数
    (?P=name)  	引用别名为name分组匹配到的字符串,引用上面的关键字参数的组，匹配一模一样的字符
    
    - 参考以下文章
    http://www.runoob.com/regexp/regexp-syntax.html
    http://www.runoob.com/python3/python3-reg-expressions.html
    
- 实例

- 字符匹配
    python	匹配 "python".

- 字符类
    实例	描述
    [Pp]ython	匹配 "Python" 或 "python"
    rub[ye]	匹配 "ruby" 或 "rube"
    [aeiou]	匹配中括号内的任意一个字母
    [0-9]	匹配任何数字。类似于 [0123456789]
    [a-z]	匹配任何小写字母
    [A-Z]	匹配任何大写字母
    [a-zA-Z0-9]	匹配任何字母及数字
    [^aeiou]	除了aeiou字母以外的所有字符
    [^0-9]	匹配除了数字外的字符

- 特殊字符类
    实例	描述
    .	匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，re.S参数。
    +   匹配+号前面的一个字符一次或多次，+只针对于它前面的一个字符
    \d	匹配任何一个数字。等价于 [0-9],[0123466789]。
    \d+ 匹配数字一次或者多次[0-9]+
    \D	匹配一个非数字字符。等价于 [^0-9]。
    \s	匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [\f\n\r\t\v]。
    \S	匹配任何非空白字符。等价于 [^\f\n\r\t\v]。
    \w	匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。注意，\w也可以匹配中文，所有慎用。
    \W	匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。 
        
# 2. Python3中的正则表达式
- RE使用大致步骤
    - compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式pattern对象   
    - 通过pattern对象提供一系列的方法对文本进行查找匹配，获得匹配结果，一个match对象
    - 最后通过match对象提供的属性和方法获得信息，根据需要进行下一步操作
- re常用函数
    - 看文章http://www.runoob.com/python3/python3-reg-expressions.html
    - compile 函数用于编译正则表达式
        - 生成一个正则表达式（ Pattern ）对象
        - 用处：经常使用的表达式先编译成表达式对象，便于后期使用
        - 供 match()，search()， findall（）函数使用
        - pattern.findall(string)
    - re.match函数
        尝试从字符串的起始位置匹配的一个模式，如果不是起始位置匹配成功的话，match()就返回none。
        re.match(pattern, string, flags=0)
    - re.search 扫描整个字符串并返回第一个成功的匹配
        re.search(pattern, string, flags=0)
    - group() 或 groups() 匹配对象函数来获取匹配表达式
    - re.sub用于替换字符串中的匹配项
        re.sub(pattern, repl, string, count=0)
    - start() 返回匹配开始的位置
    - end() 返回匹配结束的位置
    - span() 返回一个元组包含匹配 (开始,结束) 的位置 
    - re.split() 分割字符串，可以传入多个分隔符
    - 直接看实例

- re.match和re.search的区别  
    - match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；
    - search匹配整个字符串，从字符串开始进行查找，直到找到一个匹配。
    - findall查找所有，返回所有的匹配结果，返回结果直接是一个列表，不需要使用group取出
    
- 匹配中文
    - 大部分中文内容表示范围是[u4e00-u9fa5]  
    
- 贪婪和非贪婪
    - 贪婪：尽可能多的匹配（*）表示
    - 非贪婪：找到符合条件的最小内容即可，（？）表示
    - 正则默认使用贪婪匹配   
    

# 3. 特殊构造
- (?:x)   a(?=x)  a(?!=x)  (?<=x)a  (?<!x)a  
- a和x都可以是一个分组或者一个字符
   
- (?:x)非捕获组（Non-capturing group），表示不返回该组匹配的内容，当成一个普通分组，但是不占用分组编号。
    使用groups()取出分组的结果，非捕获分组不会再结果列表中
    非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成(foo){1, 2}，
    但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为(?:foo){1, 2}，
    它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。    
- a(?=x) 先行断言，意思是a后面是x，匹配a的内容的后面的内容要匹配x，\d+(?=%)表示匹配以%结尾的一个或多个数字，括号里的部分是不会返回的
- a(?!x) 先行否定断言，意思是a后面不能是x，匹配a的内容的后面的内容不匹配x即可，\d+(?!%)表示匹配不是以%结尾的一个或多个数字，括号里的部分是不会返回的
- (?<=x)a 后瞻断言，意思是a前面是x，匹配a的内容的前面的内容要匹配x
- (?<!x)a 后瞻否定断言，意思是a前面不能是x，匹配a的内容的前面的内容不匹配x即可
    